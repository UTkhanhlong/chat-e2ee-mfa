import crypto from 'crypto'; import {Storage,UserRec} from './storage'; const users=new Map<string,UserRec>(); const sessions=new Map<string,{user_id:string;revoked:boolean}>(); const id=()=>crypto.randomUUID(); export const memoryStorage:Storage={ async createUser({email,pass_hash}){const rec:UserRec={id:id(),email,pass_hash,totp_enabled:false,totp_secret:null,backups:[]}; users.set(email.toLowerCase(),rec); return {id:rec.id,email:rec.email};}, async findUserByEmail(email){return users.get(email.toLowerCase())||null;}, async addRefresh(userId,token){sessions.set(token,{user_id:userId,revoked:false});}, async rotateRefresh(oldT,newT,userId){const s=sessions.get(oldT); if(!s||s.user_id!==userId||s.revoked) return false; s.revoked=true; sessions.set(newT,{user_id:userId,revoked:false}); return true;}, async getMFA(userId){for(const u of users.values()) if(u.id===userId) return {totp_secret:u.totp_secret,totp_enabled:u.totp_enabled,backups:u.backups}; return null;}, async setTOTPSecret(userId,secret){for(const u of users.values()) if(u.id===userId){u.totp_secret=secret; return;}}, async enableTOTP(userId,backups){for(const u of users.values()) if(u.id===userId){u.backups=backups; u.totp_enabled=true; return;}}, async consumeBackup(userId,code){for(const u of users.values()) if(u.id===userId){const i=u.backups?.indexOf(code)??-1; if(i>=0){u.backups!.splice(i,1); return true;}} return false;} };
